# PV操作

## 1、什么是PV操作

PV操作由P操作源语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：

P(S)：①将信号量S的值减1，即S=S-1；②如果S>0,则该进程继续执行；否则该进程置为等待状态，排队等待队列。







V(S)：①将信号量S的值加1，即S=S+1；



## 2、PV操作的意义

我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。

## 3、什么是信号量？

信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一进程。**信号量的值与相应资源的使用情况有关:**

①：当信号量的值大于0时，表示当前可使用资源的数量

②：当它的值小于0时，其绝对值表示等待使用该资源的进程个数**注意，信号量的值仅对能有PV操作来改变**。

## 4、使用PV操作注意事项

①：每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进入临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。

②：P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。

③：互斥信号量的初值一般为1。

## 5、PV操作实例

### 5.1 实例1： 吃苹果问题

?> 桌子上有一只盘子，最多可以容纳2个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果（apple）,妈妈专向盘子中放橘子（orange）,两个二字专吃盘子中的橘子，两个女儿专吃盘子中的苹果。请用P、V操作或管进程来实现爸爸、妈妈、女儿、儿子之间的同步和互斥关系。



```c++
semaphore empty=2 //定义盘子中的剩余放水果的的位置的个数 默认为2 也就是空盘子（空缓冲区个数为2）
semaphore apple=0 // 盘子中苹果的数量
semaphore orange=0 // 盘子中橘子的数量
semaphore mutex=1 // 用来保护盘子被互斥地访问
father(){ //爸爸进程
while(true){
    P(empty) // 盘子中的水果位置减一，如果empty>=0 说明有位置可以放水果
    P(mutex)
        // 在盘子中放一个苹果
    V(mutex)
    V(apple) // 盘子中苹果数量加一
}
}
mather(){ // 妈妈进程
    while(true){
        P(empty) // 盘子中水果位置减一 如果empty>=0 说明可以放橘子
        P(mutex) 
            //
        V(mutex)
        V(orange)
    }
}
son(){ //两个儿子进程
    while(true){
        P(orange) //
        P(mutex)
        V(mutex)
        V(empty)
    }
}
daughter(){ // 两个女儿的进程
   while(true){
       P(apple)
       P(mutex)
       V(mutex)
       V(empty)
   }
}
```

### 5.2 实例2：和尚打水

?> 某寺庙，有小和尚、老和尚若干。有一水缸，有小和尚用水桶从井中提水入缸，老和尚用水桶从缸中取水饮用。水缸可容10桶水，水取自同一井中。水井径窄，每次只能容一个水桶取水。水桶总数为3个。每次入、取水仅为1桶，且不可同时进行。使用P、V操作给出小和尚、老和尚动作的算法描述。

```
Semaphore   mutexA = 1;    //保护井被互斥地访问 
Semaphore   mutexB = 1;    //保护缸被互斥地访问 
Semaphore   Count = 3；    //桶总数为3
Semaphore   full = 0;      //控制出水，刚开始，缸是空的，能取出0桶水
Semaphore   empty = 10 ;   //控制入水，刚开始，缸是空的，能倒入10桶水

//小和尚打水：
Progress（小和尚）{
          while（1）{
                   P（empty）  //判断缸是否满了（结果如果>=0,未满），决定是否需要打水
                   P（count）  //拿桶（判断是否有空闲的桶，结果如果>=0,有桶）
                   P（mutexA）{   //对井互斥访问
                    从井中打水；
                    V（mutexA）    //互斥
                   }

                    P（mutexB）{   //对缸互斥访问
                    向缸中倒水；
                    V（mutexB）    //互斥
                   }
                   V（count）//还桶，空闲桶的数量加一
                   V（full）   //缸中水的数量加一，（通知老和尚取水）
          }
}

//老和尚取水：
progress（老和尚）{
             while（1）{
                      P（full） //判断缸中是否有水，（结果如果>=0,说明缸中有水，可取水）
                      P（count）//拿桶
                      P（mutexB) //互斥
                      从缸中取水；
                      V（mutexB）//互斥
                      V(count)   //还桶
                      V（empty）//缸中还能容纳的水数量加一，（通知小和尚打水）
             }
}
```



https://zhuanlan.zhihu.com/p/61326272
